module org/sugarj/stdlib/StdTrans
imports libstrategolib

imports org/sugarj/transformations/analysis/Data
imports org/sugarj/transformations/analysis/SugarAnalyze
imports org/sugarj/transformations/ATerm
imports org/sugarj/transformations/GenerateSignatures
imports org/sugarj/transformations/LayoutSugar
imports org/sugarj/transformations/Renaming
/*
imports runtime/editor/outline-library 
*/

signature constructors
  CompilationUnit : List(Decl) -> CompilationUnit

strategies
  compile-error = ?CompileError(_,_)
  compile-error(|msg) = !CompileError(msg,<id>)
  
  desugar = fail
  changed-tree(s) = ?t; s; not(equal(|t))
  
  unlocked-bottomup(s) = ?Locked(t) < id + all(unlocked-bottomup(s)); s
  traverse(s) = compile-error <+ unlocked-bottomup(try(s; traverse(s)))
  unlock = bottomup(try(?Locked(<id>)))

  desugar-main = internal-main
  internal-main = traverse(desugar); unlock
  main = io-wrap(internal-main)
  
strategies
  debug-strat(what, s) =
    debug-analysis(!<conc-strings>("IN ", <what>, ": "));
    (s < debug-analysis(!<conc-strings>("OUT ", <what>, ": "))
       + debug-analysis(!<conc-strings>("FAILED ", <what>, ": ")); fail)

strategies
  generate-desugared :
    (selected, position, ast, path, project-path) -> (filename, result)
    where
      filename := $[[<remove-extension> path]-desug.aterm];
      result   := <desugar-main> selected

  generate-desugared-analysis :
    (selected, position, ast, path, project-path) -> (filename, result)
    where
      filename := $[[<remove-extension> path]-desug.aterm];
      <load-analysis-data <+ warn(|"Could not load analysis data.")> ast;
      result   := <desugar-main; nice-analysis-data-term> selected
  
  generate-aterm:
    (selected, position, ast, path, project-path) -> (filename, ast)
    with
      filename := <guarantee-extension(|"aterm")> path

  generate-aterm-analysis:
    (selected, position, ast, path, project-path) -> (filename, result)
    with
      filename := <guarantee-extension(|"aterm")> path;
      <load-analysis-data <+ warn(|"Could not load analysis data.")> ast;
      result   := <nice-analysis-data-term> selected
  
signature
  constructors
    Locked : a -> a
    CompileError : A * B -> C

signature
  constructors
    Some : a -> Option(a)
    None : Option(a)


signature
  constructors
    Cons : a * List(a) -> List(a)
    Nil  : List(a)
    Conc : List(a) * List(a) -> List(a)

strategies
  
  /**
   * Creates an outline given a strategy s1 that rewrites AST nodes to outline labels.
   * Only AST nodes for which s1 succeed end up in the outline.
   *
   * Example:
   *   outline = simple-label-outline(to-outline-label)
   *   to-outline-label: Entity(name, _) -> name
   *   to-outline-label: Property(name, _) -> name
   */
  simple-label-outline(s1) = collect-om(to-outline-node(s1, fail), conc)
  
  /**
   * Similar to simple-label-outline(s1), but with an additional strategy s2 that rewrites
   * AST nodes to outline nodes. Strategy s2 gets priority over strategy s1 in case both succeed.
   *
   * Example:
   *   outline = custom-label-outline(to-outline-label, to-outline-node)
   *   to-outline-label: Entity(name, _) -> name
   *   to-outline-node: Property(name, _) -> Node(name, [Node("dummy", [])])
   */
  custom-label-outline(s1, s2) = collect-om(origin-track-forced(s2) <+ to-outline-node(s1, s2), conc)

  /**
  * @internal
  * Note: we annotate labels with random numbers to guarantee that similar labels do not share the
  * same in-memory term, which would cause origins to be overwritten.
  */  
  to-outline-node(s1, s2):
    term -> Node(label, children)
    where
      random := <next-random>;
      label := <origin-track-forced(s1; term-to-outline-label; add-annotation(|random); remove-annotations(?random))> term;
      children := <get-arguments; custom-label-outline(s1, s2)> term
      
  /**
  * @internal
  */  
  term-to-outline-label =
    is-string 
      <+
    ?term{a}; origin-text; ?label; !label{a}
      <+
    write-to-string // fallback

rules

rules
  
  /**
  * Given a string of literals (e.g. "context-free syntax"), converts the string
  * into an outline label by providing it with origin information. The result is
  * that the correct portion of text in the editor gets selected, upon selecting
  * nodes with this label in the outline view.
  * Note: this strategy is useful for constructing outline labels for unnamed
  * elements. 
  *
  * @param term (e.g. 'context-free-syntax([])') provides the origin.
  */  
  literals-to-outline-label(|term):
    literals -> literals
    where
      literals' := <split-at-space> literals;
      (a, b, c, d, e) := <origin-location-offset> term;
      (before, after) := <split-before> (<origin-text> term, <Hd> literals');
      start-offset := <add> (d, <string-length> before);
      end-offset := <get-literals-end-offset(|literals', start-offset)> after;
      <origin-location-offset-set(|(a, b, c, start-offset, end-offset))> literals
      
  /**
  * @internal
  */      
  get-literals-end-offset(|literals, start-offset):
    text -> end-offset
    where
      (before, after) := <split-after> (text, <Hd> literals);
      end-offset := <get-literals-end-offset(|<Tl> literals, <add> (start-offset, <string-length> before))> after

  /**
  * @internal
  */
  get-literals-end-offset(|literals, start-offset):
    _ -> <dec> start-offset
    where
      [] := literals

rules

  /**
  * Given a term application, gets the portion of the origin text up to the start
  * of the origin text of the first subterm. If the result is an empty string, it
  * gets the origin text of the first subterm instead. Excess whitespace, such as
  * tabs and new lines, are removed.
  */
  origin-text-at-start:
    term -> result'
    where
      (cons, args) := <explode-term> term;
      offset1 := <origin-offset; ?(<id>, _)> term;
      offset2 := <Hd; origin-offset; ?(<id>, _)> args;
      offset-diff := <subt> (offset2, offset1);
      if (0 := offset-diff)
      then result' := <Hd; origin-text; guarantee-one-space-separation> args
      else result := <origin-text; explode-string; take(!offset-diff); rtrim(is-whitespace + test('\n')); implode-string> term;
        result' := <guarantee-one-space-separation> result;
        (a, b, c, d, e) := <origin-location-offset> term;
        <origin-location-offset-set(|(a, b, c, d, <add> (d, <string-length; dec> result)))> result'
      end
  
  /**
  * @internal
  */
  guarantee-one-space-separation = string-as-chars(
      map(try(test('\n' + ' '); !' '));
      foldr(![], rm-double-space <+ MkCons)
    )
  rm-double-space: (' ', l@[' '|xs]) -> l
  
signature constructors
  
  Node: label * children -> Node

strategies
  outline = fail

strategies
  
  origin-term      = prim("SSL_EXT_origin_term", <id>)
  origin-text      = prim("SSL_EXT_origin_text", <id>)
  origin-offset    = prim("SSL_EXT_origin_offset", <id>)
  origin-location  = prim("SSL_EXT_origin_location", <id>)
  origin-line      = origin-location => (<id>, _, _, _)
  origin-column    = origin-location => (_, <id>, _, _)
  origin-file      = prim("SSL_EXT_origin_file", <id>)
  origin-strip     = prim("SSL_EXT_origin_strip", <id>)
  origin-equal(|t) = prim("SSL_EXT_origin_equal", <id>, t)

	origin-location-offset = prim("SSL_EXT_origin_location_offset", <id>)
	origin-location-offset-set(|origin-location-offset) = prim("SSL_EXT_set_origin_location_offset", origin-location-offset)

  origin-language-description =
    prim("SSL_EXT_languagedescription", <id>)

  origin-language =
    origin-file; 
    origin-language-description;
    Fst
  
  origin-surrounding-comments =
    prim("SSL_EXT_origin_surrounding_comments", <origin-language>, <id>)
    
  origin-documentation-comment =
    origin-surrounding-comments;
    filter(string-as-chars(documentation-comment-chars));
    concat-strings
  
  documentation-comment-chars:
    ['*' | c*] -> <ltrim(' ' + '\t' + '\n' + '\r')> c*

  origin-track-forced(s) =
    ![<id>]; all(s); ?[<id>]

  origin-relative-path:
    trm -> rel-path
    where
      full-path := <origin-file> trm;
      len-project-prefix := <project-path; string-length; inc>;
      rel-path := <string-as-chars(drop(|len-project-prefix))> full-path

	origin-debug:
		term -> term
		with
			<(origin-term     <+ !"Failed"); debug(!"origin-trm: ")> term;
			<(origin-location <+ !"Failed"); debug(!"origin-loc: ")> term 

rules // TODO: does not belong to editor, move to a new 'utils' directory
	
	get-annotation(s) =
		has-annos;
		get-annos;
		collect-one(s)

  add-annotation(|a):
    t{a*} -> t{a, a*} where <not(is-list)> a
  
  add-annotations(|a'*):
    t{a*} -> t{a''*} where <is-list> a'*; a''* := [a'*, a*] 

  remove-annotations(s):
    t{a*} -> t{a'*}
    where
      a'* := <remove-all(s)> a*
      
  replace-annotation(s|a):
    t{a*} -> t{a, a'*}
    where
      a'* := <remove-all(s)> a*
      
  replace-annotations(s|a'*):
    t{a*} -> t{a'*, a''*}
    where
      a''* := <remove-all(s)> a*

rules
	
  project-path = prim("SSL_EXT_projectpath")
  
  plugin-path = prim("SSL_EXT_pluginpath")
    
  refresh-workspace-file:
    path -> <prim("SSL_EXT_refreshresource", path)>
    
  editor-init =
    // Ensure all dynamic rules are properly scoped
    try(dr-scope-all-end);
    dr-scope-all-start
